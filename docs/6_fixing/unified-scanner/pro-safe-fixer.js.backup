#!/usr/bin/env node
/**
 * Pro Safe Fixer - نسخة احترافية ودقيقة جداً
 * إصلاح آمن ومتحكم فيه للأخطاء البرمجية
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class ProSafeFixer {
  constructor(config = {}) {
    this.config = {
      reportPath: config.reportPath || 'ultimate-scan-report-1756646329709.json',
      testCommand: config.testCommand || 'npm run build',
      dryRun: config.dryRun || false,
      gitBackup: config.gitBackup !== false,
      maxFileSize: config.maxFileSize || 1024 * 1024, // 1MB
      ...config
    };
    
    this.results = [];
    this.stats = {
      total: 0,
      fixed: 0,
      skipped: 0,
      failed: 0,
      manual: 0
    };
    
    this.fixers = {
      'مقارنة == بدلاً من ===': this.fixEqualityOperator.bind(this),
      'Console statements في الكود': this.fixConsoleStatements.bind(this),
      'Magic numbers كبيرة': this.fixMagicNumbers.bind(this),
      'عملية FS متزامنة تبطئ الخادم': this.fixSyncFS.bind(this),
      'استخدام any يلغي type safety': this.fixAnyType.bind(this),
      'XSS: dangerouslySetInnerHTML خطر أمني': this.fixXSS.bind(this),
      'تخزين بيانات حساسة محلياً': this.fixLocalStorage.bind(this),
      'حلقة غير محسنة': this.fixUnoptimizedLoop.bind(this),
      'تعقيد عالي': this.flagComplexity.bind(this)
    };
  }

  async run() {
    console.log('🚀 بدء Pro Safe Fixer...\n');
    
    try {
      await this.validateEnvironment();
      const report = await this.loadReport();
      await this.createGitBackup();
      
      console.log(`📊 تم العثور على ${report.issues.length} مشكلة للمعالجة\n`);
      
      for (let i = 0; i < report.issues.length; i++) {
        const issue = report.issues[i];
        console.log(`[${i + 1}/${report.issues.length}] معالجة: ${path.basename(issue.file)}:${issue.line}`);
        
        await this.processIssue(issue);
        
        // تأخير صغير لتجنب الضغط على النظام
        await this.sleep(10);
      }
      
      await this.generateReports();
      this.printSummary();
      
    } catch (error) {
      console.error('❌ خطأ في التشغيل:', error.message);
      process.exit(1);
    }
  }

  async validateEnvironment() {
    // التحقق من وجود Node.js و Git
    try {
      execSync('node --version', { stdio: 'ignore' });
      execSync('git --version', { stdio: 'ignore' });
    } catch {
      throw new Error('يتطلب Node.js و Git');
    }

    // التحقق من وجود package.json
    if (!fs.existsSync('package.json')) {
      console.warn('⚠️ لم يتم العثور على package.json');
    }
  }

  async loadReport() {
    if (!fs.existsSync(this.config.reportPath)) {
      throw new Error(`تقرير الفحص غير موجود: ${this.config.reportPath}`);
    }
    
    const report = JSON.parse(fs.readFileSync(this.config.reportPath, 'utf8'));
    this.stats.total = report.issues?.length || 0;
    
    return report;
  }

  async createGitBackup() {
    if (!this.config.gitBackup) return;
    
    try {
      // التحقق من حالة Git
      const status = execSync('git status --porcelain', { encoding: 'utf8' });
      
      if (status.trim()) {
        console.log('💾 حفظ التغييرات الحالية في Git...');
        execSync('git add .', { stdio: 'ignore' });
        execSync('git commit -m "Backup before ProSafeFixer"', { stdio: 'ignore' });
      }
      
      console.log('✅ تم إنشاء نسخة احتياطية في Git\n');
    } catch (error) {
      console.warn('⚠️ لم يتم إنشاء نسخة احتياطية Git:', error.message);
    }
  }

  async processIssue(issue) {
    const result = {
      ...issue,
      status: 'unknown',
      fixApplied: false,
      testPassed: false,
      timestamp: new Date().toISOString()
    };

    try {
      // التحقق من وجود الملف
      if (!fs.existsSync(issue.file)) {
        result.status = 'file_not_found';
        this.stats.skipped++;
        this.results.push(result);
        console.log('  ⏭️ الملف غير موجود');
        return;
      }

      // التحقق من حجم الملف
      const stats = fs.statSync(issue.file);
      if (stats.size > this.config.maxFileSize) {
        result.status = 'file_too_large';
        this.stats.skipped++;
        this.results.push(result);
        console.log('  ⏭️ الملف كبير جداً');
        return;
      }

      const originalContent = fs.readFileSync(issue.file, 'utf8');
      const fixedContent = await this.applyFix(originalContent, issue);

      if (fixedContent === originalContent) {
        result.status = 'no_fix_available';
        this.stats.skipped++;
        this.results.push(result);
        console.log('  ⏭️ لا يوجد إصلاح متاح');
        return;
      }

      result.fixApplied = true;

      // تطبيق الإصلاح إذا لم يكن في وضع التجربة
      if (!this.config.dryRun) {
        fs.writeFileSync(issue.file, fixedContent, 'utf8');
      }

      // اختبار الإصلاح
      const testResult = await this.runTests();
      result.testPassed = testResult;

      if (testResult) {
        result.status = 'fixed';
        this.stats.fixed++;
        console.log('  ✅ تم الإصلاح بنجاح');
      } else {
        result.status = 'test_failed';
        this.stats.failed++;
        
        // التراجع عن الإصلاح
        if (!this.config.dryRun) {
          fs.writeFileSync(issue.file, originalContent, 'utf8');
        }
        
        console.log('  ❌ فشل الاختبار - تم التراجع');
      }

    } catch (error) {
      result.status = 'error';
      result.error = error.message;
      this.stats.failed++;
      console.log('  ❌ خطأ:', error.message);
    }

    this.results.push(result);
  }

  async applyFix(content, issue) {
    const fixer = this.findFixer(issue.message);
    
    if (!fixer) {
      return content; // لا يوجد إصلاح متاح
    }

    try {
      return await fixer(content, issue);
    } catch (error) {
      console.log(`  ⚠️ خطأ في الإصلاح: ${error.message}`);
      return content;
    }
  }

  findFixer(message) {
    for (const [pattern, fixer] of Object.entries(this.fixers)) {
      if (message.includes(pattern)) {
        return fixer;
      }
    }
    return null;
  }

  // إصلاح مشغل المساواة
  fixEqualityOperator(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      // إصلاح دقيق فقط في السطر المحدد
      lines[lineIndex] = lines[lineIndex].replace(/([^=!])==([^=])/g, '$1===$2');
    }
    
    return lines.join('\n');
  }

  // إصلاح console statements
  fixConsoleStatements(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      const line = lines[lineIndex];
      
      // إزالة console.log فقط، الاحتفاظ بـ console.error و console.warn
      if (line.includes('console.log')) {
        lines[lineIndex] = line.replace(/console\.log\([^)]*\);?/g, '// TODO: استبدل بـ logger');
      }
    }
    
    return lines.join('\n');
  }

  // إصلاح Magic Numbers
  fixMagicNumbers(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      const line = lines[lineIndex];
      
      // البحث عن أرقام كبيرة (أكثر من 100)
      const magicNumberRegex = /\b(\d{3,})\b/g;
      const matches = line.match(magicNumberRegex);
      
      if (matches) {
        let newLine = line;
        matches.forEach(num => {
          const constName = `CONST_${num}`;
          newLine = newLine.replace(new RegExp(`\\b${num}\\b`, 'g'), constName);
        });
        
        lines[lineIndex] = newLine;
        
        // إضافة الثابت في أعلى الملف
        const constDeclaration = matches.map(num => 
          `const CONST_${num} = ${num}; // TODO: اختر اسماً وصفياً`
        ).join('\n');
        
        lines.unshift(constDeclaration);
      }
    }
    
    return lines.join('\n');
  }

  // إصلاح العمليات المتزامنة
  fixSyncFS(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      let line = lines[lineIndex];
      
      // استبدال العمليات المتزامنة بغير متزامنة
      line = line.replace(/fs\.readFileSync/g, 'await fs.promises.readFile');
      line = line.replace(/fs\.writeFileSync/g, 'await fs.promises.writeFile');
      line = line.replace(/fs\.existsSync/g, 'await fs.promises.access');
      
      lines[lineIndex] = line;
    }
    
    return lines.join('\n');
  }

  // إصلاح نوع any
  fixAnyType(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      lines[lineIndex] = lines[lineIndex].replace(
        /:\s*any\b/g, 
        ': unknown // TODO: حدد النوع المناسب'
      );
    }
    
    return lines.join('\n');
  }

  // إصلاح XSS
  fixXSS(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      const line = lines[lineIndex];
      
      if (line.includes('dangerouslySetInnerHTML')) {
        lines[lineIndex] = '// TODO: استخدم DOMPurify أو مكتبة تنظيف HTML آمنة\n' + line;
      }
    }
    
    return lines.join('\n');
  }

  // إصلاح localStorage
  fixLocalStorage(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      const line = lines[lineIndex];
      
      if (line.includes('localStorage')) {
        lines[lineIndex] = '// TODO: شفّر البيانات الحساسة قبل التخزين\n' + line;
      }
    }
    
    return lines.join('\n');
  }

  // إصلاح الحلقات غير المحسنة
  fixUnoptimizedLoop(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      let line = lines[lineIndex];
      
      // إصلاح for loops
      line = line.replace(
        /for\s*\(\s*let\s+(\w+)\s*=\s*0;\s*\1\s*<\s*(\w+)\.length/g,
        'for (let $1 = 0, len = $2.length; $1 < len'
      );
      
      lines[lineIndex] = line;
    }
    
    return lines.join('\n');
  }

  // وضع علامة على التعقيد العالي
  flagComplexity(content, issue) {
    const lines = content.split('\n');
    const lineIndex = issue.line - 1;
    
    if (lineIndex >= 0 && lineIndex < lines.length) {
      lines[lineIndex] = '// TODO: قسّم هذه الدالة إلى دوال أصغر\n' + lines[lineIndex];
    }
    
    return lines.join('\n');
  }

  async runTests() {
    if (!this.config.testCommand) return true;
    
    try {
      execSync(this.config.testCommand, { 
        stdio: 'ignore',
        timeout: 30000 // 30 ثانية timeout
      });
      return true;
    } catch {
      return false;
    }
  }

  async generateReports() {
    // تقرير JSON
    const jsonReport = {
      timestamp: new Date().toISOString(),
      config: this.config,
      stats: this.stats,
      results: this.results
    };
    
    fs.writeFileSync('fix-report.json', JSON.stringify(jsonReport, null, 2));
    
    // تقرير HTML
    await this.generateHTMLReport();
    
    console.log('\n📄 تم إنشاء التقارير:');
    console.log('  - fix-report.json');
    console.log('  - fix-report.html');
  }

  async generateHTMLReport() {
    const rows = this.results.map(result => {
      const statusColor = {
        'fixed': '#28a745',
        'test_failed': '#dc3545',
        'no_fix_available': '#6c757d',
        'file_not_found': '#ffc107',
        'error': '#dc3545'
      }[result.status] || '#6c757d';
      
      return `
        <tr>
          <td>${path.basename(result.file)}</td>
          <td>${result.line}</td>
          <td>${result.category}</td>
          <td>${result.severity}</td>
          <td>${result.message}</td>
          <td style="color: ${statusColor}; font-weight: bold;">${result.status}</td>
        </tr>
      `;
    }).join('');

    const html = `
<!DOCTYPE html>
<html dir="rtl" lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>تقرير الإصلاح - Pro Safe Fixer</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; }
        .header { background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .stats { display: flex; gap: 20px; margin-bottom: 20px; }
        .stat-card { background: #fff; border: 1px solid #dee2e6; padding: 15px; border-radius: 8px; text-align: center; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #dee2e6; padding: 12px; text-align: right; }
        th { background: #e9ecef; font-weight: bold; }
        tr:nth-child(even) { background: #f8f9fa; }
        .fixed { color: #28a745; }
        .failed { color: #dc3545; }
    </style>
</head>
<body>
    <div class="header">
        <h1>🔧 تقرير الإصلاح - Pro Safe Fixer</h1>
        <p>تم الإنشاء في: ${new Date().toLocaleString('ar-SA')}</p>
    </div>
    
    <div class="stats">
        <div class="stat-card">
            <h3>${this.stats.total}</h3>
            <p>إجمالي المشاكل</p>
        </div>
        <div class="stat-card">
            <h3 class="fixed">${this.stats.fixed}</h3>
            <p>تم الإصلاح</p>
        </div>
        <div class="stat-card">
            <h3 class="failed">${this.stats.failed}</h3>
            <p>فشل الإصلاح</p>
        </div>
        <div class="stat-card">
            <h3>${this.stats.skipped}</h3>
            <p>تم التخطي</p>
        </div>
    </div>
    
    <table>
        <thead>
            <tr>
                <th>الملف</th>
                <th>السطر</th>
                <th>الفئة</th>
                <th>الخطورة</th>
                <th>الوصف</th>
                <th>الحالة</th>
            </tr>
        </thead>
        <tbody>
            ${rows}
        </tbody>
    </table>
</body>
</html>
    `;
    
    fs.writeFileSync('fix-report.html', html);
  }

  printSummary() {
    console.log('\n📊 ملخص النتائج:');
    console.log(`  📝 إجمالي المشاكل: ${this.stats.total}`);
    console.log(`  ✅ تم الإصلاح: ${this.stats.fixed}`);
    console.log(`  ❌ فشل الإصلاح: ${this.stats.failed}`);
    console.log(`  ⏭️ تم التخطي: ${this.stats.skipped}`);
    
    const successRate = this.stats.total > 0 ? 
      ((this.stats.fixed / this.stats.total) * 100).toFixed(1) : 0;
    
    console.log(`  📈 معدل النجاح: ${successRate}%`);
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// تشغيل السكريبت
if (require.main === module) {
  const args = process.argv.slice(2);
  const config = {};
  
  // معالجة المعاملات
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--dry-run':
        config.dryRun = true;
        break;
      case '--no-git':
        config.gitBackup = false;
        break;
      case '--report':
        config.reportPath = args[++i];
        break;
      case '--test':
        config.testCommand = args[++i];
        break;
    }
  }
  
  const fixer = new ProSafeFixer(config);
  fixer.run().catch(console.error);
}

module.exports = ProSafeFixer;