#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

class SimpleCodeFixer {
  constructor() {
    this.fixedCount = 0;
    this.skippedCount = 0;
    
    // ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ÿßŸÑÿ®ÿ≥Ÿäÿ∑ÿ© ÿßŸÑŸÇÿßÿ®ŸÑÿ© ŸÑŸÑÿ•ÿµŸÑÿßÿ≠ ÿßŸÑÿ¢ŸÖŸÜ
    this.safeFixes = {
      // ÿ•ÿ≤ÿßŸÑÿ© console.log ŸÅŸÇÿ∑ (ŸÑŸäÿ≥ console.error ÿ£Ÿà console.warn)
      removeConsoleLog: /console\.log\([^)]*\);?\s*\n?/g,
      
      // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿßŸÅÿßÿ™ ÿßŸÑÿ≤ÿßÿ¶ÿØÿ© ŸÅŸä ŸÜŸáÿßŸäÿ© ÿßŸÑÿ£ÿ≥ÿ∑ÿ±
      removeTrailingSpaces: /[ \t]+$/gm,
      
      // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ£ÿ≥ÿ∑ÿ± ÿßŸÑŸÅÿßÿ±ÿ∫ÿ© ÿßŸÑŸÖÿ™ÿ™ÿßŸÑŸäÿ© (ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ÿ≥ÿ∑ÿ±ŸäŸÜ)
      removeExtraEmptyLines: /\n{3,}/g,
      
      // ÿ•ÿ∂ÿßŸÅÿ© ŸÅÿßÿµŸÑÿ© ŸÖŸÜŸÇŸàÿ∑ÿ© ŸÖŸÅŸÇŸàÿØÿ© ŸÅŸä ŸÜŸáÿßŸäÿ© ÿßŸÑÿ≥ÿ∑ÿ± (ÿ≠ÿßŸÑÿßÿ™ ÿ®ÿ≥Ÿäÿ∑ÿ© ŸÅŸÇÿ∑)
      addMissingSemicolon: /([a-zA-Z0-9_\]})]\s*)(\n)/g,
      
      // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿßŸÅÿßÿ™ ÿßŸÑÿ≤ÿßÿ¶ÿØÿ© ÿ≠ŸàŸÑ ÿßŸÑÿ£ŸÇŸàÿßÿ≥
      fixSpacesAroundBrackets: /\s+\)/g,
      
      // ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÖÿ≥ÿßŸÅÿßÿ™ ÿ≠ŸàŸÑ ÿßŸÑÿπŸÖŸÑŸäÿßÿ™ ÿßŸÑÿ®ÿ≥Ÿäÿ∑ÿ©
      fixSpacesAroundOperators: /([a-zA-Z0-9_])(=)([a-zA-Z0-9_])/g
    };

    // ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿ≥ÿ™ÿ´ŸÜÿßÿ© ŸÖŸÜ ÿßŸÑÿ•ÿµŸÑÿßÿ≠
    this.excludeFiles = [
      'package-lock.json',
      'node_modules',
      '.git',
      'dist',
      'build',
      '.next',
      'coverage'
    ];

    // ÿ£ŸÜŸàÿßÿπ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿØÿπŸàŸÖÿ©
    this.supportedExtensions = ['.js', '.ts', '.jsx', '.tsx', '.css', '.scss'];
  }

  shouldSkipFile(filePath) {
    return this.excludeFiles.some(exclude => filePath.includes(exclude));
  }

  isSupportedFile(filePath) {
    const ext = path.extname(filePath);
    return this.supportedExtensions.includes(ext);
  }

  applySafeFixes(content, filePath) {
    let fixed = content;
    let hasChanges = false;

    // ÿ•ÿ≤ÿßŸÑÿ© console.log ŸÅŸÇÿ∑
    const newContent = fixed.replace(this.safeFixes.removeConsoleLog, '');
    if (newContent !== fixed) {
      fixed = newContent;
      hasChanges = true;
      console.log(`  ‚úì Removed console.log statements`);
    }

    // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸÖÿ≥ÿßŸÅÿßÿ™ ÿßŸÑÿ≤ÿßÿ¶ÿØÿ©
    const trimmed = fixed.replace(this.safeFixes.removeTrailingSpaces, '');
    if (trimmed !== fixed) {
      fixed = trimmed;
      hasChanges = true;
      console.log(`  ‚úì Removed trailing spaces`);
    }

    // ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑÿ£ÿ≥ÿ∑ÿ± ÿßŸÑŸÅÿßÿ±ÿ∫ÿ© ÿßŸÑÿ≤ÿßÿ¶ÿØÿ©
    const cleanLines = fixed.replace(this.safeFixes.removeExtraEmptyLines, '\n\n');
    if (cleanLines !== fixed) {
      fixed = cleanLines;
      hasChanges = true;
      console.log(`  ‚úì Cleaned extra empty lines`);
    }

    // ÿ•ÿµŸÑÿßÿ≠ ÿßŸÑŸÖÿ≥ÿßŸÅÿßÿ™ ÿ≠ŸàŸÑ ÿßŸÑÿ£ŸÇŸàÿßÿ≥
    const fixedBrackets = fixed.replace(/\s+\)/g, ')');
    if (fixedBrackets !== fixed) {
      fixed = fixedBrackets;
      hasChanges = true;
      console.log(`  ‚úì Fixed spaces around brackets`);
    }

    return { content: fixed, hasChanges };
  }

  async fixFile(filePath) {
    try {
      if (this.shouldSkipFile(filePath) || !this.isSupportedFile(filePath)) {
        this.skippedCount++;
        return false;
      }

      const content = fs.readFileSync(filePath, 'utf8');
      const { content: fixedContent, hasChanges } = this.applySafeFixes(content, filePath);

      if (hasChanges) {
        // ÿ•ŸÜÿ¥ÿßÿ° ŸÜÿ≥ÿÆÿ© ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
        const backupPath = filePath + '.backup';
        fs.writeFileSync(backupPath, content);
        
        // ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸèÿµŸÑÿ≠
        fs.writeFileSync(filePath, fixedContent);
        
        console.log(`üîß Fixed: ${path.relative(process.cwd(), filePath)}`);
        this.fixedCount++;
        return true;
      }

      return false;
    } catch (error) {
      console.error(`‚ùå Error fixing ${filePath}:`, error.message);
      return false;
    }
  }

  async scanDirectory(dirPath) {
    const items = fs.readdirSync(dirPath);
    
    for (const item of items) {
      const fullPath = path.join(dirPath, item);
      const stat = fs.statSync(fullPath);
      
      if (stat.isDirectory()) {
        if (!this.shouldSkipFile(fullPath)) {
          await this.scanDirectory(fullPath);
        }
      } else if (stat.isFile()) {
        await this.fixFile(fullPath);
      }
    }
  }

  async run(targetPath = '.') {
    console.log('üöÄ Starting Simple Code Fixer...\n');
    
    const startTime = Date.now();
    
    if (fs.statSync(targetPath).isFile()) {
      await this.fixFile(targetPath);
    } else {
      await this.scanDirectory(targetPath);
    }
    
    const duration = Date.now() - startTime;
    
    console.log('\nüìä Summary:');
    console.log(`  ‚úÖ Files fixed: ${this.fixedCount}`);
    console.log(`  ‚è≠Ô∏è  Files skipped: ${this.skippedCount}`);
    console.log(`  ‚è±Ô∏è  Duration: ${duration}ms`);
    
    if (this.fixedCount > 0) {
      console.log('\nüí° Backup files created with .backup extension');
      console.log('üí° Review changes before committing');
    }
  }

  // ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑŸÖŸÑŸÅÿßÿ™ ŸÖŸÜ ÿßŸÑŸÜÿ≥ÿÆ ÿßŸÑÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿäÿ©
  async restoreBackups(targetPath = '.') {
    console.log('üîÑ Restoring from backups...');
    
    const restoreFile = (filePath) => {
      const backupPath = filePath + '.backup';
      if (fs.existsSync(backupPath)) {
        fs.copyFileSync(backupPath, filePath);
        fs.unlinkSync(backupPath);
        console.log(`  ‚Ü©Ô∏è  Restored: ${path.relative(process.cwd(), filePath)}`);
        return true;
      }
      return false;
    };

    const scanForBackups = (dirPath) => {
      const items = fs.readdirSync(dirPath);
      let restoredCount = 0;
      
      for (const item of items) {
        const fullPath = path.join(dirPath, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory() && !this.shouldSkipFile(fullPath)) {
          restoredCount += scanForBackups(fullPath);
        } else if (item.endsWith('.backup')) {
          const originalPath = fullPath.replace('.backup', '');
          if (fs.existsSync(originalPath)) {
            fs.copyFileSync(fullPath, originalPath);
            fs.unlinkSync(fullPath);
            console.log(`  ‚Ü©Ô∏è  Restored: ${path.relative(process.cwd(), originalPath)}`);
            restoredCount++;
          }
        }
      }
      return restoredCount;
    };

    const restoredCount = scanForBackups(targetPath);
    console.log(`\n‚úÖ Restored ${restoredCount} files from backups`);
  }
}

// ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ≥ŸÉÿ±Ÿäÿ®ÿ™
if (require.main === module) {
  const fixer = new SimpleCodeFixer();
  const args = process.argv.slice(2);
  
  if (args.includes('--restore')) {
    fixer.restoreBackups(args[1] || '.');
  } else {
    fixer.run(args[0] || '.');
  }
}

module.exports = SimpleCodeFixer;